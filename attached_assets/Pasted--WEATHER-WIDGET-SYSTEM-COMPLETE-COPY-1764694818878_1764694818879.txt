=============================================================
WEATHER WIDGET SYSTEM - COMPLETE COPY/PASTE FOR AI AGENTS
=============================================================

INSTRUCTIONS: Implement a floating weather button with dynamic icons and glows.
Uses FREE Open-Meteo API (no API key needed).

=============================================================
STEP 1: GENERATE 8 WEATHER ICONS
=============================================================
Save to: attached_assets/generated_images/ (or adjust import paths)

1. weather_icon_floating.png
   "Friendly cartoon sun with warm rays, 3D render, floating orb, bright yellow-orange gradient, soft glow, transparent background, 512x512"

2. clear_night_moon_stars_icon_floating.png
   "Crescent moon with twinkling stars, soft purple-blue glow, 3D cartoon style, dreamy night sky, transparent background, 512x512"

3. partly_cloudy_night_icon_floating.png
   "Crescent moon partially behind fluffy cloud, soft indigo glow, 3D cartoon, transparent background, 512x512"

4. cloudy_overcast_night_icon_floating.png
   "Dark gray fluffy clouds, subtle moonlight glow behind, 3D cartoon, moody atmosphere, transparent background, 512x512"

5. rainy_night_icon_floating.png
   "Dark cloud with falling rain drops, subtle blue-purple glow, 3D cartoon, transparent background, 512x512"

6. stormy_night_lightning_icon_floating.png
   "Dark storm cloud with bright lightning bolt, dramatic purple-violet glow, 3D cartoon, transparent background, 512x512"

7. snowy_night_icon_floating.png
   "Fluffy cloud with falling snowflakes, soft white-blue glow, 3D cartoon, winter night feel, transparent background, 512x512"

8. foggy_misty_night_icon_floating.png
   "Layered fog/mist clouds, subtle gray-blue glow, mysterious atmosphere, 3D cartoon, transparent background, 512x512"

=============================================================
STEP 2: CREATE server/services/weather.ts
=============================================================

interface WeatherData {
  location: { city: string; state?: string; country: string; lat: number; lon: number };
  current: { temp: number; feelsLike: number; humidity: number; windSpeed: number; windDirection: string; description: string; icon: string; visibility: number; pressure: number; isNight: boolean };
  hourly: Array<{ time: string; temp: number; icon: string; description: string; precipitation: number }>;
  daily: Array<{ date: string; tempHigh: number; tempLow: number; icon: string; description: string; precipitation: number }>;
}

interface GeocodingResult { lat: number; lon: number; name: string; state?: string; country: string }

export class WeatherService {
  private baseUrl = 'https://api.open-meteo.com/v1';
  private geocodingUrl = 'https://geocoding-api.open-meteo.com/v1';

  private getWindDirection(degrees: number): string {
    const directions = ['N', 'NNE', 'NE', 'ENE', 'E', 'ESE', 'SE', 'SSE', 'S', 'SSW', 'SW', 'WSW', 'W', 'WNW', 'NW', 'NNW'];
    return directions[Math.round(degrees / 22.5) % 16];
  }

  private getWeatherIcon(code: number, isDay: boolean = true): string {
    const icons: Record<number, { day: string; night: string }> = {
      0: { day: 'â˜€ï¸', night: 'ğŸŒ™' }, 1: { day: 'ğŸŒ¤ï¸', night: 'ğŸŒ¤ï¸' }, 2: { day: 'â›…', night: 'â˜ï¸' }, 3: { day: 'â˜ï¸', night: 'â˜ï¸' },
      45: { day: 'ğŸŒ«ï¸', night: 'ğŸŒ«ï¸' }, 48: { day: 'ğŸŒ«ï¸', night: 'ğŸŒ«ï¸' },
      51: { day: 'ğŸŒ§ï¸', night: 'ğŸŒ§ï¸' }, 53: { day: 'ğŸŒ§ï¸', night: 'ğŸŒ§ï¸' }, 55: { day: 'ğŸŒ§ï¸', night: 'ğŸŒ§ï¸' },
      56: { day: 'ğŸŒ¨ï¸', night: 'ğŸŒ¨ï¸' }, 57: { day: 'ğŸŒ¨ï¸', night: 'ğŸŒ¨ï¸' },
      61: { day: 'ğŸŒ§ï¸', night: 'ğŸŒ§ï¸' }, 63: { day: 'ğŸŒ§ï¸', night: 'ğŸŒ§ï¸' }, 65: { day: 'ğŸŒ§ï¸', night: 'ğŸŒ§ï¸' },
      66: { day: 'ğŸŒ¨ï¸', night: 'ğŸŒ¨ï¸' }, 67: { day: 'ğŸŒ¨ï¸', night: 'ğŸŒ¨ï¸' },
      71: { day: 'â„ï¸', night: 'â„ï¸' }, 73: { day: 'â„ï¸', night: 'â„ï¸' }, 75: { day: 'â„ï¸', night: 'â„ï¸' }, 77: { day: 'â„ï¸', night: 'â„ï¸' },
      80: { day: 'ğŸŒ¦ï¸', night: 'ğŸŒ§ï¸' }, 81: { day: 'ğŸŒ¦ï¸', night: 'ğŸŒ§ï¸' }, 82: { day: 'â›ˆï¸', night: 'â›ˆï¸' },
      85: { day: 'ğŸŒ¨ï¸', night: 'ğŸŒ¨ï¸' }, 86: { day: 'ğŸŒ¨ï¸', night: 'ğŸŒ¨ï¸' },
      95: { day: 'â›ˆï¸', night: 'â›ˆï¸' }, 96: { day: 'â›ˆï¸', night: 'â›ˆï¸' }, 99: { day: 'â›ˆï¸', night: 'â›ˆï¸' },
    };
    return (icons[code] || icons[0])[isDay ? 'day' : 'night'];
  }

  private getWeatherDescription(code: number): string {
    const d: Record<number, string> = {
      0: 'Clear sky', 1: 'Mainly clear', 2: 'Partly cloudy', 3: 'Overcast', 45: 'Foggy', 48: 'Rime fog',
      51: 'Light drizzle', 53: 'Moderate drizzle', 55: 'Dense drizzle', 56: 'Light freezing drizzle', 57: 'Dense freezing drizzle',
      61: 'Slight rain', 63: 'Moderate rain', 65: 'Heavy rain', 66: 'Light freezing rain', 67: 'Heavy freezing rain',
      71: 'Slight snow', 73: 'Moderate snow', 75: 'Heavy snow', 77: 'Snow grains',
      80: 'Slight showers', 81: 'Moderate showers', 82: 'Violent showers', 85: 'Light snow showers', 86: 'Heavy snow showers',
      95: 'Thunderstorm', 96: 'Thunderstorm with hail', 99: 'Severe thunderstorm',
    };
    return d[code] || 'Unknown';
  }

  async geocodeZip(zipCode: string): Promise<GeocodingResult | null> {
    try {
      const res = await fetch(`${this.geocodingUrl}/search?name=${zipCode}&count=1&language=en&format=json`);
      if (!res.ok) return null;
      const data = await res.json();
      if (!data.results?.length) return null;
      const r = data.results[0];
      return { lat: r.latitude, lon: r.longitude, name: r.name, state: r.admin1, country: r.country_code };
    } catch { return null; }
  }

  async getWeather(lat: number, lon: number): Promise<WeatherData | null> {
    try {
      const params = new URLSearchParams({
        latitude: lat.toString(), longitude: lon.toString(),
        current: 'temperature_2m,relative_humidity_2m,apparent_temperature,weather_code,wind_speed_10m,wind_direction_10m,surface_pressure,visibility,is_day',
        hourly: 'temperature_2m,weather_code,precipitation_probability',
        daily: 'weather_code,temperature_2m_max,temperature_2m_min,precipitation_probability_max',
        temperature_unit: 'fahrenheit', wind_speed_unit: 'mph', precipitation_unit: 'inch',
        timezone: 'auto', forecast_days: '7', forecast_hours: '24',
      });
      const res = await fetch(`${this.baseUrl}/forecast?${params}`);
      if (!res.ok) throw new Error('API error');
      const data = await res.json();
      const isDay = data.current?.is_day === 1;
      return {
        location: { city: '', country: '', lat, lon },
        current: {
          temp: Math.round(data.current?.temperature_2m || 0),
          feelsLike: Math.round(data.current?.apparent_temperature || 0),
          humidity: data.current?.relative_humidity_2m || 0,
          windSpeed: Math.round(data.current?.wind_speed_10m || 0),
          windDirection: this.getWindDirection(data.current?.wind_direction_10m || 0),
          description: this.getWeatherDescription(data.current?.weather_code || 0),
          icon: this.getWeatherIcon(data.current?.weather_code || 0, isDay),
          visibility: Math.round((data.current?.visibility || 0) / 1609.34),
          pressure: Math.round((data.current?.surface_pressure || 0) * 0.02953),
          isNight: !isDay,
        },
        hourly: (data.hourly?.time || []).slice(0, 24).map((t: string, i: number) => ({
          time: new Date(t).toLocaleTimeString('en-US', { hour: 'numeric' }),
          temp: Math.round(data.hourly?.temperature_2m?.[i] || 0),
          icon: this.getWeatherIcon(data.hourly?.weather_code?.[i] || 0, true),
          description: this.getWeatherDescription(data.hourly?.weather_code?.[i] || 0),
          precipitation: data.hourly?.precipitation_probability?.[i] || 0,
        })),
        daily: (data.daily?.time || []).map((t: string, i: number) => ({
          date: new Date(t).toLocaleDateString('en-US', { weekday: 'short' }),
          tempHigh: Math.round(data.daily?.temperature_2m_max?.[i] || 0),
          tempLow: Math.round(data.daily?.temperature_2m_min?.[i] || 0),
          icon: this.getWeatherIcon(data.daily?.weather_code?.[i] || 0, true),
          description: this.getWeatherDescription(data.daily?.weather_code?.[i] || 0),
          precipitation: data.daily?.precipitation_probability_max?.[i] || 0,
        })),
      };
    } catch { return null; }
  }

  async getWeatherByZip(zipCode: string): Promise<WeatherData | null> {
    const loc = await this.geocodeZip(zipCode);
    if (!loc) return null;
    const weather = await this.getWeather(loc.lat, loc.lon);
    if (!weather) return null;
    weather.location = { ...weather.location, city: loc.name, state: loc.state, country: loc.country };
    return weather;
  }
}

export const weatherService = new WeatherService();

=============================================================
STEP 3: ADD TO server/routes.ts
=============================================================

import { weatherService } from "./services/weather";

app.get("/api/weather/zip/:zipCode", async (req, res) => {
  try {
    const weather = await weatherService.getWeatherByZip(req.params.zipCode);
    if (!weather) return res.status(404).json({ error: "Location not found" });
    res.json(weather);
  } catch { res.status(500).json({ error: "Failed to fetch weather" }); }
});

=============================================================
STEP 4: CREATE client/src/components/FloatingWeatherButton.tsx
=============================================================

import { useState, useEffect, useMemo } from "react";
import { motion } from "framer-motion";
import { useQuery } from "@tanstack/react-query";
import { Loader2 } from "lucide-react";

import weatherIconDay from "@assets/generated_images/weather_icon_floating.png";
import clearNightIcon from "@assets/generated_images/clear_night_moon_stars_icon_floating.png";
import partlyCloudyNightIcon from "@assets/generated_images/partly_cloudy_night_icon_floating.png";
import cloudyNightIcon from "@assets/generated_images/cloudy_overcast_night_icon_floating.png";
import rainyNightIcon from "@assets/generated_images/rainy_night_icon_floating.png";
import stormyNightIcon from "@assets/generated_images/stormy_night_lightning_icon_floating.png";
import snowyNightIcon from "@assets/generated_images/snowy_night_icon_floating.png";
import foggyNightIcon from "@assets/generated_images/foggy_misty_night_icon_floating.png";

interface WeatherData {
  location: { city: string; state?: string; country: string; lat: number; lon: number };
  current: { temp: number; feelsLike: number; humidity: number; windSpeed: number; windDirection: string; description: string; icon: string; visibility: number; pressure: number; isNight?: boolean };
  hourly: Array<{ time: string; temp: number; icon: string; description: string; precipitation: number }>;
  daily: Array<{ date: string; tempHigh: number; tempLow: number; icon: string; description: string; precipitation: number }>;
}

function getWeatherGlow(desc: string, isNight: boolean): string {
  const d = desc.toLowerCase();
  if (d.includes('thunder') || d.includes('storm')) return isNight ? 'shadow-[0_0_30px_rgba(139,92,246,0.8),0_0_60px_rgba(139,92,246,0.5)]' : 'shadow-[0_0_30px_rgba(147,51,234,0.7),0_0_60px_rgba(147,51,234,0.4)]';
  if (d.includes('rain') || d.includes('drizzle')) return isNight ? 'shadow-[0_0_30px_rgba(99,102,241,0.7),0_0_60px_rgba(99,102,241,0.4)]' : 'shadow-[0_0_30px_rgba(59,130,246,0.7),0_0_60px_rgba(59,130,246,0.4)]';
  if (d.includes('snow') || d.includes('sleet')) return isNight ? 'shadow-[0_0_30px_rgba(203,213,225,0.8),0_0_60px_rgba(203,213,225,0.5)]' : 'shadow-[0_0_30px_rgba(226,232,240,0.7),0_0_60px_rgba(226,232,240,0.4)]';
  if (d.includes('cloud') || d.includes('overcast')) return isNight ? 'shadow-[0_0_30px_rgba(100,116,139,0.6),0_0_60px_rgba(100,116,139,0.3)]' : 'shadow-[0_0_30px_rgba(148,163,184,0.6),0_0_60px_rgba(148,163,184,0.3)]';
  if (d.includes('fog') || d.includes('mist')) return isNight ? 'shadow-[0_0_30px_rgba(71,85,105,0.6),0_0_60px_rgba(71,85,105,0.3)]' : 'shadow-[0_0_30px_rgba(100,116,139,0.6),0_0_60px_rgba(100,116,139,0.3)]';
  if (d.includes('clear') || d.includes('sunny')) return isNight ? 'shadow-[0_0_30px_rgba(129,140,248,0.7),0_0_60px_rgba(129,140,248,0.4)]' : 'shadow-[0_0_30px_rgba(250,204,21,0.8),0_0_60px_rgba(250,204,21,0.5)]';
  return isNight ? 'shadow-[0_0_30px_rgba(99,102,241,0.6),0_0_60px_rgba(99,102,241,0.3)]' : 'shadow-[0_0_30px_rgba(6,182,212,0.6),0_0_60px_rgba(6,182,212,0.3)]';
}

function getGlowColor(desc: string, isNight: boolean): string {
  const d = desc.toLowerCase();
  if (d.includes('thunder') || d.includes('storm')) return isNight ? 'from-violet-600/40 to-purple-900/30' : 'from-purple-500/30 to-purple-700/20';
  if (d.includes('rain') || d.includes('drizzle')) return isNight ? 'from-indigo-600/40 to-blue-900/30' : 'from-blue-500/30 to-blue-700/20';
  if (d.includes('snow') || d.includes('sleet')) return isNight ? 'from-slate-400/40 to-slate-700/30' : 'from-slate-300/30 to-slate-500/20';
  if (d.includes('cloud') || d.includes('overcast')) return isNight ? 'from-slate-600/40 to-slate-800/30' : 'from-slate-400/30 to-slate-600/20';
  if (d.includes('fog') || d.includes('mist')) return isNight ? 'from-slate-500/30 to-slate-700/20' : 'from-gray-400/30 to-gray-600/20';
  if (d.includes('clear') || d.includes('sunny')) return isNight ? 'from-indigo-500/40 to-violet-800/30' : 'from-yellow-400/40 to-orange-500/20';
  return isNight ? 'from-indigo-500/30 to-violet-700/20' : 'from-cyan-500/30 to-primary/20';
}

function getWeatherIcon(desc: string, isNight: boolean): string {
  if (!isNight) return weatherIconDay;
  const d = desc.toLowerCase();
  if (d.includes('thunder') || d.includes('storm')) return stormyNightIcon;
  if (d.includes('rain') || d.includes('drizzle') || d.includes('shower')) return rainyNightIcon;
  if (d.includes('snow') || d.includes('sleet') || d.includes('ice')) return snowyNightIcon;
  if (d.includes('fog') || d.includes('mist') || d.includes('haze')) return foggyNightIcon;
  if (d.includes('overcast')) return cloudyNightIcon;
  if (d.includes('cloud') || d.includes('partly')) return partlyCloudyNightIcon;
  return clearNightIcon;
}

export default function FloatingWeatherButton() {
  const [localZip, setLocalZip] = useState<string | null>(null);
  useEffect(() => { const s = localStorage.getItem('weatherZip'); if (s) setLocalZip(s); }, []);
  const effectiveZip = localZip || "10001";

  const { data: weather, isLoading } = useQuery<WeatherData>({
    queryKey: ["/api/weather/zip", effectiveZip],
    queryFn: async () => { const r = await fetch(`/api/weather/zip/${effectiveZip}`); if (!r.ok) throw new Error(); return r.json(); },
    staleTime: 600000, refetchInterval: 1800000,
  });

  const isNight = weather?.current?.isNight ?? false;
  const description = weather?.current?.description ?? '';
  const glowClass = useMemo(() => weather ? getWeatherGlow(description, isNight) : '', [weather, description, isNight]);
  const gradientClass = useMemo(() => weather ? getGlowColor(description, isNight) : 'from-cyan-500/30 to-primary/20', [weather, description, isNight]);
  const currentIcon = useMemo(() => getWeatherIcon(description, isNight), [description, isNight]);

  return (
    <motion.button
      onClick={() => console.log('Weather clicked', weather)}
      className={`fixed bottom-24 right-4 z-50 w-16 h-16 md:w-20 md:h-20 rounded-full bg-gradient-to-br ${gradientClass} backdrop-blur-md border border-white/20 flex items-center justify-center cursor-pointer transition-all duration-300 hover:scale-110 ${glowClass}`}
      initial={{ scale: 0, opacity: 0 }} animate={{ scale: 1, opacity: 1 }}
      transition={{ type: "spring", stiffness: 260, damping: 20, delay: 0.5 }}
      whileHover={{ scale: 1.1 }} whileTap={{ scale: 0.95 }}
    >
      {isLoading ? <Loader2 className="w-8 h-8 animate-spin text-primary" /> : (
        <div className="relative w-full h-full flex items-center justify-center">
          <motion.img src={currentIcon} alt="Weather" className="w-12 h-12 md:w-14 md:h-14 object-contain drop-shadow-lg"
            animate={{ y: [0, -3, 0], rotate: isNight ? [0, 1, -1, 0] : [0, 2, -2, 0] }}
            transition={{ duration: isNight ? 6 : 4, repeat: Infinity, ease: "easeInOut" }} />
          {weather && (
            <div className={`absolute -bottom-1 -right-1 backdrop-blur-sm rounded-full px-1.5 py-0.5 border ${isNight ? 'bg-indigo-900/80 border-indigo-400/30' : 'bg-black/80 border-white/20'}`}>
              <span className={`text-[10px] font-mono font-bold ${isNight ? 'text-indigo-100' : 'text-white'}`}>{weather.current.temp}Â°</span>
            </div>
          )}
        </div>
      )}
    </motion.button>
  );
}

=============================================================
STEP 5: ADD TO App.tsx
=============================================================

import FloatingWeatherButton from "./components/FloatingWeatherButton";

// Inside your component return, add:
<FloatingWeatherButton />

=============================================================
STEP 6: VITE CONFIG ALIAS (if needed)
=============================================================

// In vite.config.ts, add to resolve.alias:
"@assets": path.resolve(import.meta.dirname, "attached_assets"),

=============================================================
DEPENDENCIES
=============================================================

npm install framer-motion @tanstack/react-query lucide-react

=============================================================
SUMMARY
=============================================================

- FREE Open-Meteo API (no key needed)
- Auto day/night detection based on location
- 8 custom icons for weather conditions
- Dynamic glow effects (purple=storm, blue=rain, yellow=sun)
- Saves user ZIP to localStorage
- Default: NYC (10001)
- Caches 10 min, refreshes every 30 min

=============================================================